#!/usr/bin/env python3

import gi
gi.require_version('Hinawa', '1.0')

from misc.cui_kit import CuiKit
from efw.efw_unit import EfwUnit

def handle_hardware_info(unit, args):
    for i, ch in enumerate(unit.info['phys-inputs']):
        print('{0:02d}: {1}'.format(i, ch))
    for i, ch in enumerate(unit.info['phys-outputs']):
        print('{0:02d}: {1}'.format(i, ch))

def handle_clock_source(unit, args):
    ops = ('get', 'set')
    rate, source = unit.get_clock_state()
    if len(args) > 0:
        source = args[0]
        unit.set_clock_state(rate, source)
    else:
        print(source)
    print('Arguments for clock-source command:')
    print('  clock-source OPERATION [SOURCE]')
    print('    OPERATION: {0}'.format(', '.join(ops)))
    print('    SOURCE:    {0}'.format(', '.join(unit.get_clock_labels())))
    return True

def handle_sampling_rate(unit, args):
    rate, source = unit.get_clock_state()
    if len(args) > 0:
        rate = int(args[0])
        unit.set_clock_state(rate, source)
    else:
        print(rate)
    return True

def handle_control_room_mirroring(unit, args):
    if len(args) > 0:
        unit.set_control_room_mirroring(args[0])
    else:
        print(unit.get_control_room_mirroring())
    return True

def handle_digital_input(unit, args):
    if len(args) > 0:
        unit.set_digital_input_mode(args[0])
    else:
        print(unit.get_digital_input_mode())
    return True

def handle_phantom_powering(unit, args):
    if len(args) > 0:
        unit.set_phantom_powering(args[0])
    else:
        print(unit.get_phantom_powering())
    return True

def handle_box_state(unit, args):
    states = unit.get_box_states()
    if len(args) > 0:
        name = args[0]
        if len(args) > 1:
            value = args[1]
            unit.set_box_states(name, value)
        else:
            print(unit.get_box_states(name))
        return True
    print('Arguments for box-state command:')
    print('  box-state name [value]')
    print('    name: {0}'.format(', '.join(states)))
    return False

def handle_room_mirroring(unit, args):
    if len(args) > 0:
        value = int(args[0])
        unit.set_control_room_mirroring(value)
    else:
        print(unit.get_control_room_mirroring())
    return True

def handle_rx_stream_mapping(unit, args):
    if not unit.info['features']['rx-mapping']:
        print('Not supported in this unit.')
        return False
    print(unit.info['phys-outputs'])
    if len(args) > 0:
        output = args[0]
        if len(args) > 1:
            source = args[1]
        else:
            maps = unit.get_stream_mapping()
            print(maps['rx-map'])
        return True
    print('Arguments for xx-stream-mapping command:')
    print('  rx-stream-mapping output [source]')
    outputs = unit.info['phys-outputs']
    ports = []
    for i, port in enumerate(outputs):
        if i % 2:
            ports.append(port)
    print('    output: {0}')
    print('    source: {0}')

def handle_tx_stream_mapping(unit, args):
    if not unit.info['features']['tx-mapping']:
        print('Not supported in this unit.')
        return False
    print(unit.info['phys-inputs'])
    if len(args) > 0:
        input = args[0]
        if len(args) > 1:
            source = args[1]
        else:
            maps = unit.get_stream_mapping()
            print(maps['tx-map'])
        return True
    print('Arguments for tx-stream-mapping command:')
    print('  tx-stream-mapping input [source]')
    inputs = unit.info['phys-inputs']
    print('    input: {0}')
    print('    source: {0}')


def handle_output(unit, args):
    ops = {
        'gain':     (unit.set_phys_out_gain, unit.get_phys_out_gain),
        'mute':     (unit.set_phys_out_mute, unit.get_phys_out_mute),
        'nominal':  (unit.set_phys_out_nominal, unit.get_phys_out_nominal)
    }
    if len(args) > 1:
        operation = args[0]
        ch = int(args[1])
        if len(args) == 3:
            value = int(args[2])
            ops[operation][0](ch, value)
        else:
            print(ops[operation][1](ch))
        return True
    print('Arguments for output command:')
    print('  output operation ch [value]')
    print('    operation: {0}'.format(', '.join(ops)))
    print('    ch: 0-{0}'.format(len(unit.info['phys-outputs']) - 1))
    print('    value: []')
    return False

def handle_input(unit, args):
    ops = {
        'nominal':  (unit.set_phys_in_nominal, unit.get_phys_in_nominal),
    }
    if len(args) > 1:
        operation = args[0]
        ch = int(args[1])
        if len(args) == 3:
            value = int(args[2])
            ops[operation][0](ch, value)
        else:
            print(ops[operation][1](ch))
        return True
    print('Arguments for input command:')
    print('  input operation ch [value]')
    print('    operation: {0}'.format(', '.join(ops)))
    print('    ch: 0-{0}'.format(len(unit.info['phys-inputs']) - 1))
    print('    value: []')
    return False

def handle_playback(unit, args):
    ops = {
        'gain': (unit.set_playback_gain, unit.get_playback_gain),
        'mute': (unit.set_playback_mute, unit.get_playback_mute),
        'solo': (unit.set_playback_solo, unit.get_playback_solo)
    }
    if len(args) > 1:
        operation = args[0]
        ch = int(args[1])
        if len(args) == 3:
            value = int(args[2])
            ops[operation][0](ch, value)
        else:
            print(ops[operation][1](ch))
        return True
    print('Arguments for playback command:')
    print('  playback operation ch [value]')
    print('    operation: {0}'.format(', '.join(ops)))
    print('    ch: 0-{0}'.format(unit.info['playback-channels'] - 1))
    print('    value: []')
    return False

def handle_monitor(unit, args):
    ops = {
        'gain':  (unit.set_monitor_gain, unit.get_monitor_gain),
        'mute':  (unit.set_monitor_mute, unit.get_monitor_mute),
        'solo':  (unit.set_monitor_solo, unit.get_monitor_solo),
        'pan':   (unit.set_monitor_pan, unit.get_monitor_pan,)
    }
    if len(args) > 2:
        operation = args[0]
        input = int(args[1])
        output = int(args[2])
        if len(args) == 4:
            value = int(args[3])
            ops[operation][0](input, output, value)
        else:
            print(ops[operation][1](input, output))
        return True
    print('Arguments for monitor command:')
    print('  monitor operation ch [value]')
    print('    operation: {0}'.format(', '.join(ops)))
    print('    input:   0-{0}'.format(len(unit.info['phys-inputs']) - 1))
    print('    output:  0-{0}'.format(len(unit.info['phys-outputs']) - 1))
    print('    value:   []')
    return False

def handle_listen_metering(unit, args):
    import time
    import signal
    # This is handled by another context.
    def handle_unix_signal(signum, frame):
        sys.exit()
    signal.signal(signal.SIGINT, handle_unix_signal)
    while 1:
        meters = unit.get_metering()
        for name in sorted(meters):
            print(name, meters[name])
        print('')
        time.sleep(0.1)
    return True

cmds = {
    'hardware-info':        handle_hardware_info,
    'clock-source':         handle_clock_source,
    'sampling-rate':        handle_sampling_rate,
    'control-room':         handle_room_mirroring,
    'digital-input':        handle_digital_input,
    'phantom-powering':     handle_phantom_powering,
    'box-state':            handle_box_state,
    'rx-stream-mapping':    handle_rx_stream_mapping,
    'tx-stream-mapping':    handle_tx_stream_mapping,
    'output':               handle_output,
    'input':                handle_input,
    'playback':             handle_playback,
    'monitor':              handle_monitor,
    'listen-metering':      handle_listen_metering,
}

fullpath = CuiKit.seek_snd_unit_path()
if fullpath:
    unit = EfwUnit(fullpath)
    CuiKit.dispatch_command(unit, cmds)
