#!/usr/bin/env python3

from misc.cui_kit import CuiKit
from efw.efw_unit import EfwUnit

def handle_clock_source(unit, args):
    rate, source = unit.get_clock_state()
    if len(args) > 0:
        source = args[0]
        unit.set_clock_state(rate, source)
    else:
        print(source)
    return True

def handle_sampling_rate(unit, args):
    rate, source = unit.get_clock_state()
    if len(args) > 0:
        rate = int(args)
        unit.set_clock_state(rate, source)
    else:
        print(rate)
    return True

def handle_control_room_mirroring(unit, args):
    if len(args) > 0:
        unit.set_control_room_mirroring(args[0])
    else:
        print(unit.get_control_room_mirroring())
    return True

def handle_digital_input(unit, args):
    if len(args) > 0:
        unit.set_digital_input_mode(args[0])
    else:
        print(unit.get_digital_input_mode())
    return True

def handle_phantom_powering(unit, args):
    if len(args) > 0:
        unit.set_phantom_powering(args[0])
    else:
        print(unit.get_phantom_powering())
    return True

def handle_box_state(unit, args):
    states = unit.get_box_states()
    if len(args) > 0:
        name = args[0]
        if len(args) > 1:
            value = args[1]
            unit.set_box_states(name, value)
        else:
            print(unit.get_box_states(name))
        return True
    print('Arguments for box-state command:')
    print('  box-state name [value]')
    print('    name: {0}'.format(', '.join(states)))
    return False

def handle_room_mirroring(unit, args):
    if len(args) > 0:
        value = int(args[0])
        unit.set_control_room_mirroring(value)
    else:
        print(unit.get_control_room_mirroring())
    return True

def handle_stream_mapping(unit, args):
    if len(args) > 0:
        value = int(args[0])
    else:
        print(unit.get_stream_mapping())
    return True

def handle_output(unit, args):
    ops = {
        'gain':     (unit.set_phys_out_gain, unit.get_phys_out_gain),
        'mute':     (unit.set_phys_out_mute, unit.get_phys_out_mute),
        'nominal':  (unit.set_phys_out_nominal, unit.get_phys_out_nominal)
    }
    if len(args) > 1:
        operation = args[0]
        ch = int(args[1])
        if len(args) == 3:
            value = int(args[2])
            ops[operation][0](ch, value)
        else:
            print(ops[operation][1](ch))
        return True
    print('Arguments for output command:')
    print('  output operation ch [value]')
    print('    operation: {0}'.format(', '.join(ops)))
    print('    ch: 0-{0}'.format(len(unit.info['phys-outputs']) - 1))
    print('    value: []')
    return False

def handle_input(unit, args):
    ops = {
        'nominal':  (unit.set_phys_in_nominal, unit.get_phys_in_nominal),
    }
    if len(args) > 1:
        operation = args[0]
        ch = int(args[1])
        if len(args) == 3:
            value = int(args[2])
            ops[operation][0](ch, value)
        else:
            print(ops[operation][1](ch))
        return True
    print('Arguments for input command:')
    print('  input operation ch [value]')
    print('    operation: {0}'.format(', '.join(ops)))
    print('    ch: 0-{0}'.format(len(unit.info['phys-inputs']) - 1))
    print('    value: []')
    return False

def handle_playback(unit, args):
    ops = {
        'gain': (unit.set_playback_gain, unit.get_playback_gain),
        'mute': (unit.set_playback_mute, unit.get_playback_mute),
        'solo': (unit.set_playback_solo, unit.get_playback_solo)
    }
    if len(args) > 1:
        operation = args[0]
        ch = int(args[1])
        if len(args) == 3:
            value = int(args[2])
            ops[operation][0](ch, value)
        else:
            print(ops[operation][1](ch))
        return True
    print('Arguments for playback command:')
    print('  playback operation ch [value]')
    print('    operation: {0}'.format(', '.join(ops)))
    print('    ch: 0-{0}'.format(unit.info['playback-channels'] - 1))
    print('    value: []')
    return False

def handle_monitor(unit, args):
    ops = {
        'gain':  (unit.set_monitor_gain, unit.get_monitor_gain),
        'mute':  (unit.set_monitor_mute, unit.get_monitor_mute),
        'solo':  (unit.set_monitor_solo, unit.get_monitor_solo),
        'pan':   (unit.set_monitor_pan, unit.get_monitor_pan,)
    }
    if len(args) > 2:
        operation = args[0]
        input = int(args[1])
        output = int(args[2])
        if len(args) == 4:
            value = int(args[3])
            ops[operation][0](input, output, value)
        else:
            print(ops[operation][1](input, output))
        return True
    print('Arguments for monitor command:')
    print('  monitor operation ch [value]')
    print('    operation: {0}'.format(', '.join(ops)))
    print('    input:   0-{0}'.format(len(unit.info['phys-inputs']) - 1))
    print('    output:  0-{0}'.format(len(unit.info['phys-outputs']) - 1))
    print('    value:   []')
    return False

def handle_listen_metering(unit, args):
    import time
    import signal
    # This is handled by another context.
    def handle_unix_signal(signum, frame):
        sys.exit()
    signal.signal(signal.SIGINT, handle_unix_signal)
    while 1:
        meters = unit.get_metering()
        for name in sorted(meters):
            print(name, meters[name])
        print('')
        time.sleep(0.1)
    return True

cmds = {
    'clock-source':     handle_clock_source,
    'sampling-rate':    handle_sampling_rate,
    'control-room':     handle_room_mirroring,
    'digital-input':    handle_digital_input,
    'phantom-powering': handle_phantom_powering,
    'box-state':        handle_box_state,
    'stream-mapping':   handle_stream_mapping,
    'output':           handle_output,
    'input':            handle_input,
    'playback':         handle_playback,
    'monitor':          handle_monitor,
    'listen-metering':  handle_listen_metering,
}

fullpath = CuiKit.seek_snd_unit_path()
if fullpath:
    unit = EfwUnit(fullpath)
    CuiKit.dispatch_command(unit, cmds)
