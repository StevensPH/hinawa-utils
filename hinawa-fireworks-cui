#!/usr/bin/env python3

from misc.cui_kit import CuiKit
from efw.efw_unit import EfwUnit

def handle_hardware_info(unit, args):
    print('Supported features:')
    for key, value in unit.info['features'].items():
        if value:
            print('    ', key)
    print('Supported signals for clock source:')
    for key, value in unit.info['clock-sources'].items():
        if value:
            print('    ', key)
    print('Supported sampling rates:')
    for key, value in unit.info['sampling-rates'].items():
        if value:
            print('    ', key)
    print('List of physical ports:')
    print('    Inputs:')
    for i, ch in enumerate(unit.info['phys-inputs']):
        print('        {0:02d}: {1}'.format(i, ch))
    print('    Outputs:')
    for i, ch in enumerate(unit.info['phys-outputs']):
        print('        {0:02d}: {1}'.format(i, ch))
    print('The number of channels for mixer:')
    print('    Capture: ', unit.info['capture-channels'])
    print('    Playback:', unit.info['playback-channels'])
    print('The number of PCM channels in a stream:')
    rates = ['44.1/48.0', '88.2/96.0']
    if unit.info['sampling-rates'][176400]:
        rates.append('176.4/192.0')
    print('    tx:')
    for index, rate in enumerate(rates):
        print('{0:>16}: {1}'.format(rate,
                                    unit.info['tx-stream-channels'][index]))
    print('    tx:')
    for index, rate in enumerate(rates):
        print('{0:>16}: {1}'.format(rate,
                                    unit.info['rx-stream-channels'][index]))
    print('Firmware versions:')
    for key, value in unit.info['firmware-versions'].items():
        print('{0:>8}: {1}'.format(key, value))

def handle_clock_source(unit, args):
    ops = ('set', 'get')
    sources = []
    for key, value in unit.info['clock-sources'].items():
        if value:
            sources.append(key)
    if len(args) > 0 and args[0] in ops:
        rate, source = unit.get_clock_state()
        if args[0] == ops[0] and len(args) > 1 and args[1] in sources:
            source = args[1]
            unit.set_clock_state(rate, source)
        else:
            print(source)
        return True
    print('Arguments for clock-source command:')
    print('  clock-source OPERATION [SOURCE]')
    print('    OPERATION: {0}'.format(', '.join(ops)))
    print('    SOURCE:    {0}'.format(', '.join(sources)))

    return False

def handle_sampling_rate(unit, args):
    ops = ('set', 'get')
    rates = []
    for key, value in unit.info['sampling-rates'].items():
        if value:
            rates.append(key)
    if len(args) > 0 and args[0] in ops:
        rate, source = unit.get_clock_state()
        if args[0] == ops[0] and len(args) > 1 and int(args[1]) in rates:
            rate = int(args[1])
            unit.set_clock_state(rate, source)
        else:
            print(rate)
        return True
    print('Arguments for sampling-rate command:')
    print('  clock-source OPERATION [SOURCE]')
    print('    OPERATION: {0}'.format(', '.join(ops)))
    print('    SOURCE:    {0}'.format(', '.join(map(str, rates))))
    return False

def handle_control_room(unit, args):
    if len(args) > 0:
        unit.set_control_room_mirroring(args[0])
    else:
        print(unit.get_control_room_mirroring())
    return True

def handle_digital_input(unit, args):
    ops = ('set', 'get')
    avails = ('spdif-coax', 'aesebu-xlr', 'spdif-opt', 'adat-opt')
    modes = []
    for avail in avails:
        if avail in unit.info['features'] and unit.info['features'][avail]:
            modes.append(avail)
    if len(args) > 0:
        op = args[0]
        if op == ops[0] and len(args) > 1 and args[1] in modes:
            unit.set_digital_input_mode(args[1])
        else:
            print(unit.get_digital_input_mode())
        return True
    print('Arguments for digital-input command:')
    print('  digital-input OPERATION [MODE]')
    print('    OPERATION: {0}'.format(', '.join(ops)))
    print('    MODE:      {0}'.format(', '.join(modes)))
    return False

def handle_phantom_powering(unit, args):
    ops = ('set', 'get')
    modes = ('off', 'on')
    if len(args) > 0 and args[0] in ops:
        op = args[0]
        if len(args) > 1 and op == ops[0] and args[1] in modes:
            mode = args[1]
            unit.set_phantom_powering(modes.index(mode))
        else:
            print(modes[unit.get_phantom_powering()])
        return True
    print('Arguments for phantom-powering command:')
    print('  phantom-powering OPERATION [MODE]')
    print('    OPERATION: {0}'.format(', '.join(ops)))
    print('    MODE:      {0}'.format(', '.join(modes)))
    return False

def handle_box_state(unit, args):
    ops = ('set', 'get')
    values = ('off', 'on')
    if len(args) > 1:
        op = args[0]
        name = args[1]
        if op == ops[0] and len(args) > 2 and args[2] in values:
            unit.set_box_states(name, values.index(args[2]))
        else:
            states = unit.get_box_states()
            print(states[name])
        return True
    states = unit.get_box_states()
    print('Arguments for box-state command:')
    print('  box-state NAME [VALUE]')
    print('    NAME: {0}'.format(', '.join(states)))
    print('    VALUE: off/on')
    return False

def handle_rx_stream_mapping(unit, args):
    ops = ('set', 'get')
    # Generate stereo pair for outputs
    outputs = []
    prev = ''
    num = 0
    for index, name in enumerate(unit.info['phys-outputs']):
        if index % 2 == 0:
            if prev is not name:
                num = 0
            outputs.append('{0}-{1}/{2}'.format(name, num * 2 + 1, num * 2 + 2))
            prev = name
            num += 1
    # Generate stereo pair for sources
    sources = []
    for ch in range(unit.info['rx-stream-channels'][0]):
        if ch % 2 == 0:
            sources.append('stream-{0}/{1}'.format(ch+ 1, ch + 2))
    maps = unit.get_stream_mapping()
    if len(args) > 1 and args[0] in ops and args[1] in outputs:
        op = args[0]
        output = outputs.index(args[1])
        if op == ops[0] and len(args) > 2 and args[2] in sources:
            source = sources.index(args[2]) * 2
            maps['rx-map'][output] = source
            unit.set_stream_mapping(maps['rx-map'], maps['tx-map'])
        else:
            print(sources[maps['rx-map'][output] // 2])
        return True
    print('Arguments for rx-stream-mapping command:')
    print('  rx-stream-mapping OPERATION OUTPUT [SOURCE]')
    print('    OPERATION: {0}'.format(', '.join(ops)))
    print('    OUTPUT:    {0}'.format(', '.join(outputs)))
    print('    SOURCE:    {0}'.format(', '.join(sources)))

def handle_tx_stream_mapping(unit, args):
    ops = ('set', 'get')
    # Generate stereo pair for inputs
    inputs = []
    prev = ''
    num = 0
    for index, name in enumerate(unit.info['phys-inputs']):
        if index % 2 == 0:
            if prev is not name:
                num = 0
            inputs.append('{0}-{1}/{2}'.format(name, num * 2 + 1, num * 2 + 2))
            prev = name
            num += 1
    # Generate stereo pair for sinks
    sinks = []
    for ch in range(unit.info['tx-stream-channels'][0]):
        if ch % 2 == 0:
            sinks.append('stream-{0}/{1}'.format(ch+ 1, ch + 2))
    maps = unit.get_stream_mapping()
    if len(args) > 1 and args[0] in ops and args[1] in inputs:
        op = args[0]
        input = inputs.index(args[1])
        if op == ops[0] and len(args) > 2 and args[2] in sinks:
            sink = sinks.index(args[2]) * 2
            maps['tx-map'][input] = sink
            unit.set_stream_mapping(maps['tx-map'], maps['tx-map'])
        else:
            print(sinks[maps['tx-map'][input] // 2])
        return True
    print('Arguments for tx-stream-mapping command:')
    print('  tx-stream-mapping OPERATION INPUT [SINK]')
    print('    OPERATION: {0}'.format(', '.join(ops)))
    print('    INPUT:     {0}'.format(', '.join(inputs)))
    print('    SINK:      {0}'.format(', '.join(sinks)))


def handle_output(unit, args):
    ops = {
        'gain':     (unit.set_phys_out_gain, unit.get_phys_out_gain),
        'mute':     (unit.set_phys_out_mute, unit.get_phys_out_mute),
        'nominal':  (unit.set_phys_out_nominal, unit.get_phys_out_nominal)
    }
    if len(args) > 1:
        operation = args[0]
        ch = int(args[1])
        if len(args) == 3:
            value = int(args[2])
            ops[operation][0](ch, value)
        else:
            print(ops[operation][1](ch))
        return True
    print('Arguments for output command:')
    print('  output operation ch [value]')
    print('    operation: {0}'.format(', '.join(ops)))
    print('    ch: 0-{0}'.format(len(unit.info['phys-outputs']) - 1))
    print('    value: []')
    return False

def handle_input(unit, args):
    ops = {
        'nominal':  (unit.set_phys_in_nominal, unit.get_phys_in_nominal),
    }
    if len(args) > 1:
        operation = args[0]
        ch = int(args[1])
        if len(args) == 3:
            value = int(args[2])
            ops[operation][0](ch, value)
        else:
            print(ops[operation][1](ch))
        return True
    print('Arguments for input command:')
    print('  input operation ch [value]')
    print('    operation: {0}'.format(', '.join(ops)))
    print('    ch: 0-{0}'.format(len(unit.info['phys-inputs']) - 1))
    print('    value: []')
    return False

def handle_playback(unit, args):
    ops = {
        'gain': (unit.set_playback_gain, unit.get_playback_gain),
        'mute': (unit.set_playback_mute, unit.get_playback_mute),
        'solo': (unit.set_playback_solo, unit.get_playback_solo)
    }
    if len(args) > 1:
        operation = args[0]
        ch = int(args[1])
        if len(args) == 3:
            value = int(args[2])
            ops[operation][0](ch, value)
        else:
            print(ops[operation][1](ch))
        return True
    print('Arguments for playback command:')
    print('  playback operation ch [value]')
    print('    operation: {0}'.format(', '.join(ops)))
    print('    ch: 0-{0}'.format(unit.info['playback-channels'] - 1))
    print('    value: []')
    return False

def handle_monitor(unit, args):
    ops = {
        'gain':  (unit.set_monitor_gain, unit.get_monitor_gain),
        'mute':  (unit.set_monitor_mute, unit.get_monitor_mute),
        'solo':  (unit.set_monitor_solo, unit.get_monitor_solo),
        'pan':   (unit.set_monitor_pan, unit.get_monitor_pan,)
    }
    if len(args) > 2:
        operation = args[0]
        input = int(args[1])
        output = int(args[2])
        if len(args) == 4:
            value = int(args[3])
            ops[operation][0](input, output, value)
        else:
            print(ops[operation][1](input, output))
        return True
    print('Arguments for monitor command:')
    print('  monitor operation ch [value]')
    print('    operation: {0}'.format(', '.join(ops)))
    print('    input:   0-{0}'.format(len(unit.info['phys-inputs']) - 1))
    print('    output:  0-{0}'.format(len(unit.info['phys-outputs']) - 1))
    print('    value:   []')
    return False

def handle_listen_metering(unit, args):
    import time
    import signal
    # This is handled by another context.
    def handle_unix_signal(signum, frame):
        sys.exit()
    signal.signal(signal.SIGINT, handle_unix_signal)
    while 1:
        meters = unit.get_metering()
        for name in sorted(meters):
            print(name, meters[name])
        print('')
        time.sleep(0.1)
    return True

def get_available_commands(features):
    cmds = {
        'hardware-info':        handle_hardware_info,
        'clock-source':         handle_clock_source,
        'sampling-rate':        handle_sampling_rate,
        'box-state':            handle_box_state,
        'output':               handle_output,
        'input':                handle_input,
        'playback':             handle_playback,
        'monitor':              handle_monitor,
        'listen-metering':      handle_listen_metering,
    }
    if features['control-room-mirroring']:
        cmds['control-room'] = handle_control_room
    if features['rx-mapping']:
        cmds['rx-stream-mapping'] = handle_rx_stream_mapping
    if features['tx-mapping']:
        cmds['tx-stream-mapping'] = handle_tx_stream_mapping
    if features['spdif-coax'] or features['aesebu-xlr'] or \
       features['spdif-opt'] or features['adat-opt']:
        cmds['digital-input'] = handle_digital_input
    if features['phantom-powering']:
        cmds['phantom-powering'] = handle_phantom_powering
    return cmds

fullpath = CuiKit.seek_snd_unit_path()
if fullpath:
    unit = EfwUnit(fullpath)
    cmds = get_available_commands(unit.info['features'])
    CuiKit.dispatch_command(unit, cmds)
