#!/usr/bin/env python3

import time
import signal
import sys

from misc.cui_kit import CuiKit
from bebob.maudio_normal import MaudioNormal

def _handle_target_volume(unit, args, cmd, targets_func, set_func, get_func):
    CHS = (0, 1)
    OPS = ('set', 'get')
    targets = targets_func()
    if len(targets) == 0:
        print('Not supported')
        return True
    if len(args) >= 1 and args[0] in targets:
        target = args[0]
        if len(args) >= 2 and int(args[1]) in CHS:
            ch = int(args[1])
            if len(args) >= 3 and args[2] in OPS:
                op = args[2]
                if op == 'set' and len(args) >= 4:
                    db = float(args[3])
                    set_func(target, ch, db)
                    return True
                elif op == 'get':
                    print(get_func(target, ch))
                    return True
    print('Arguments for {0} command:'.format(cmd))
    print('  {0} TARGET CH OP [dB]'.format(cmd))
    print('    TARGET:   [{0}]'.format('|'.join(targets)))
    print('    CH:       [{0}]'.format('|'.join(map(str, CHS))))
    print('    OP:       [{0}]'.format('|'.join(OPS)))
    print('    dB:       [-128.00..128.00] if OP=set')
    return False

def handle_input_volume(unit, args):
    return _handle_target_volume(unit, args, 'input-volume',
                                 unit.get_input_labels,
                                 unit.set_input_volume, unit.get_input_volume)

def handle_aux_input_volume(unit, args):
    return _handle_target_volume(unit, args, 'aux-input-volume',
                                 unit.get_aux_input_labels,
                                 unit.set_aux_input_volume,
                                 unit.get_aux_input_volume)

def handle_output_volume(unit, args):
    return _handle_target_volume(unit, args, 'output-volume',
                                 unit.get_output_labels,
                                 unit.set_output_volume,
                                 unit.get_output_volume)

def handle_headphone_volume(unit, args):
    return _handle_target_volume(unit, args, 'headphone-volume',
                                 unit.get_headphone_labels,
                                 unit.set_headphone_volume,
                                 unit.get_headphone_volume)

def handle_aux_output_volume(unit, args):
    CHS = (0, 1)
    OPS = ('set', 'get')
    if len(unit.get_aux_input_labels()) == 0:
        print('Not supported')
        return False
    if len(args) > 0 and int(args[0]) in CHS:
        ch = int(args[0])
        if len(args) > 1 and args[1] in OPS:
            op = args[1]
            if len(args) > 2 and op == 'set':
                db = float(args[2])
                unit.set_aux_master_volume(ch, db)
                return True
            elif op == 'get':
                print(unit.get_aux_master_volume(ch))
                return True
    print('Arguments for aux-output-volume command:')
    print('  aux-output-volume CH OP [dB]')
    print('    CH:     [{0}]'.format('|'.join(map(str, CHS))))
    print('    OP:     [{0}]'.format('|'.join(OPS)))
    print('    dB:     [-128.0..128.0] if OP=set')
    return False

def handle_mixer_routing(unit, args):
    OPS = ('set', 'get')
    targets = unit.get_mixer_labels()
    sources = unit.get_mixer_source_labels()
    if len(args) >= 1 and args[0] in targets:
        target = args[0]
        if len(args) >= 2 and args[1] in sources:
            source = args[1]
            if len(args) >= 3 and args[2] in OPS:
                op = args[2]
                if len(args) >= 4 and op == 'set':
                    enable = bool(int(args[3]))
                    unit.set_mixer_routing(target, source, enable)
                    return True
                elif op == 'get':
                    print(unit.get_mixer_routing(target, source))
                    return True
    print('Arguments for mixer-routing command:')
    print('  mixer-routing TARGET SOURCE [ENABLE]')
    print('    TARGET: [{0}]'.format('|'.join(targets)))
    print('    SOURCE: [{0}]'.format('|'.join(sources)))
    print('    OP:     [{0}]'.format('|'.join(OPS)))
    print('    ENABLE: [0|1]')
    return False

def _handle_target_source(unit, args, cmd, targets_func, sources_func,
                          set_func, get_func):
    OPS = ('set', 'get')
    targets = targets_func()
    if len(args) >= 1 and args[0] in targets:
        target = args[0]
        if len(args) >= 2 and args[1] in OPS:
            op = args[1]
            if len(args) >= 3 and op == 'set' and \
               args[2] in sources_func(target):
                source = args[2]
                set_func(target, source)
                return True
            elif op == 'get':
                print(get_func(target))
                return True
    print('Arguments for {0} command:'.format(cmd))
    print('  {0} TARGET OP [SRC]'.format(cmd))
    print('    TARGET:    [{0}]'.format('|'.join(targets)))
    print('    OP:        [{0}]'.format('|'.join(OPS)))
    for target in targets:
        sources = sources_func(target)
        print('    SRC:       [{0}] if TARGET={1} and OP=set'.format(
                                                '|'.join(sources), target))
    return False

def handle_headphone_source(unit, args):
    return _handle_target_source(unit, args, 'headphone-source',
                                 unit.get_headphone_labels,
                                 unit.get_headphone_source_labels,
                                 unit.set_headphone_source,
                                 unit.get_headphone_source)

def handle_output_source(unit, args):
    return _handle_target_source(unit, args,  'output-source',
                                 unit.get_output_labels,
                                 unit.get_output_source_labels,
                                 unit.set_output_source,
                                 unit.get_output_source)

def handle_listen_metering(unit, args):
    # This is handled by another context.
    def handle_unix_signal(signum, frame):
        sys.exit()
    signal.signal(signal.SIGINT, handle_unix_signal)
    labels = unit.get_meter_labels()
    while 1:
        # At higher sampling rate, this causes timeout frequently.
        try:
            meters = unit.get_meters()
            for name in sorted(meters):
                print('{0}: {1:08x}'.format(name, meters[name]))
        except Exception as e:
            pass
        print('')
        time.sleep(0.1)
    return True

def handle_clock_source(unit, args):
    OPS = ('set', 'get')
    sources = unit.get_clock_source_labels()
    if len(args) > 0 and args[0] in OPS:
        op = args[0]
        if len(args) > 1 and op == 'set' and args[1] in sources:
            source = args[1]
            unit.set_clock_source(source)
            return True
        elif op == 'get':
            print(unit.get_clock_source())
            return True
    print('Arguments for clock-source command:')
    print('  clock-source OP [SRC]')
    print('    OP:     {0}'.format('|'.join(OPS)))
    print('    SRC:    {0} if OP=set'.format('|'.join(sources)))
    print('  Packet streaming should be stopped.')
    return False

cmds = {
    'input-volume':         handle_input_volume,
    'aux-input-volume':     handle_aux_input_volume,
    'aux-output-volume':    handle_aux_output_volume,
    'mixer-routing':        handle_mixer_routing,
    'output-volume':        handle_output_volume,
    'output-source':        handle_output_source,
    'headphone-volume':     handle_headphone_volume,
    'headphone-source':     handle_headphone_source,
    'listen-metering':      handle_listen_metering,
    'clock-source':         handle_clock_source,
}

fullpath = CuiKit.seek_snd_unit_path()
if fullpath:
    unit = MaudioNormal(fullpath)
    CuiKit.dispatch_command(unit, cmds)
