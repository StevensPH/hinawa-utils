#!/usr/bin/env python3

from misc.cui_kit import CuiKit
from bebob.maudio_normal import MaudioNormal

def handle_clock_source(unit, args):
    if len(args) == 0:
        print(unit.get_clock_source())
        return True
    elif not unit.get_property('streaming'):
        source = args[0]
        if source in unit.get_clock_source_labels():
            unit.set_clock_source(source)
            return True
    print('Arguments for clock-source command:')
    print('  clock-source source')
    print('    source: {0}'.format(', '.join(unit.get_clock_source_labels())))
    print('  Packet streaming should be stopped.')

def handle_input_volume(unit, args):
    if len(args) > 1:
        input = args[0]
        ch = int(args[1])
        if input in unit.get_input_labels() and ch < 3:
            if len(args) == 3:
                db = float(args[2])
                unit.set_input_volume(input, ch, db)
            else:
                print(unit.get_input_volume(input, ch))
            return True
    print('Arguments for input-volume command:')
    print('  input-volume target ch [dB]')
    print('    target:    [{0}]'.format((', ').join(unit.get_input_labels())))
    print('    ch:        [0, 1]')
    print('    dB:        [-128.0..128.0]')
    return False

def handle_aux_input_volume(unit, args):
    if len(unit.get_aux_input_labels()) == 0:
        print('Not supported')
        return False
    if len(args) > 1:
        aux_input = args[0]
        ch = int(args[1])
        if aux_input in unit.get_aux_input_labels() and ch < 3:
            if len(args) == 3:
                db = float(args[2])
                unit.set_aux_input_volume(aux_input, ch, db)
            else:
                print(unit.get_aux_input_volume(aux_input, ch))
            return True
    print('Arguments for aux-input-volume command:')
    print('  aux-input-volume aux-input ch [dB]')
    print('    aux-input: {0}'.format((', ').join(unit.get_aux_input_labels())))
    print('    ch:        0, 1')
    print('    dB:        [-128.0..128.0]')
    return False

def handle_aux_output_volume(unit, args):
    if len(unit.get_aux_input_labels()) == 0:
        print('Not supported')
        return False
    if len(args) > 0:
        ch = int(args[0])
        if ch < 3:
            if len(args) == 2:
                db = float(args[1])
                unit.set_aux_master_volume(ch, db)
            else:
                print(unit.get_aux_master_volume(ch))
            return True
    print('Arguments for aux-output-volume command:')
    print('  aux-output-volume ch [dB]')
    print('    ch:        [0, 1]')
    print('    dB:        [-128.0..128.0]')
    return False

def handle_mixer_routing(unit, args):
    if len(args) > 1:
        sink = args[0]
        source = args[1]
        if sink in unit.get_mixer_sink_labels() and \
           source in unit.get_mixer_source_labels():
            if len(args) == 3:
                if int(args[2]) > 0:
                    value = 0x0000
                else:
                    value = 0x8000
                unit.set_mixer_routing(source, sink, value)
            else:
                value = unit.get_mixer_routing(source, sink)
                if value > 0x0000:
                    print(0)
                else:
                    print(1)
            return True
    print('Arguments for mixer-routing command:')
    print('  mixer-routing sink source [value]')
    for sink in unit.get_mixer_sink_labels():
        print('    {0} [{1}] [0, 1]'.format(
            sink, ', '.join(unit.get_mixer_source_labels())
        ))
    return False

def handle_output_volume(unit, args):
    if len(args) > 1:
        output = args[0]
        ch = int(args[1])
        if output in unit.get_output_labels() and ch < 3:
            if len(args) == 3:
                db = float(args[2])
                unit.set_output_volume(output, ch, db)
            else:
                print(unit.get_output_volume(output, ch))
            return True
    print('Arguments for output-volume command:')
    print('  output-volume output ch [dB]')
    print('    source:    [{0}]'.format((', ').join(unit.get_output_labels())))
    print('    ch:        [0, 1]')
    print('    dB:        [-128.0..128.0]')
    return False

def handle_output_source(unit, args):
    if len(args) > 0:
        output = args[0]
        if output in unit.get_output_labels():
            if len(args) == 2 and \
               args[1] in unit.get_output_source_labels(output):
                source = args[1]
                unit.set_output_source(output, source)
            else:
                print(unit.get_output_source(output))
            return True
    print('Arguments for output-source command:')
    print('  output-source output [source]')
    for output in unit.get_output_labels():
        sources = unit.get_output_source_labels(output)
        if len(sources) > 1:
            print('    {0} [{1}]'.format(output, ', '.join(sources)))
        else:
            print('    {0} [{1} (fixed)]'.format(output, sources[0]))
    return False

def handle_headphone_volume(unit, args):
    if len(unit.get_headphone_labels()) == 0:
        print('Not supported')
        return False
    if len(args) > 1:
        headphone = args[0]
        ch = int(args[1])
        if headphone in unit.get_headphone_labels() and ch < 3:
            if len(args) == 3:
                db = float(args[2])
                unit.set_headphone_volume(headphone, ch, db)
            else:
                print(unit.get_headphone_volume(headphone, ch))
            return True
    print('Arguments for headphone-volume command:')
    print('  headphone-volume headphone ch [dB]')
    print('  headphone: {0}'.format((', ').join(unit.get_headphone_labels())))
    print('  ch:        0, 1')
    print('  dB:        [-128.0..128.0]')
    return False

def handle_headphone_source(unit, args):
    if len(unit.get_headphone_labels()) == 0:
        print('Not supported')
        return False
    if len(args) > 0:
        headphone = args[0]
        if headphone in unit.get_headphone_labels():
            if len(args) == 2 and \
               args[1] in unit.get_headphone_source_labels():
                source = args[1]
                unit.set_headphone_source(headphone, source)
            else:
                print(unit.get_headphone_source(headphone))
            return True
    print('Arguments for headphone-source command:')
    print('  headphone-source headphone [source]')
    print('    headphone: {0}'.format(', '.join(unit.get_headphone_labels())))
    print('    source:    {0}'.format(', '.join(unit.get_headphone_source_labels())))
    return False

def handle_listen_metering(unit, args):
    import time, signal, sys
    # This is handled by another context.
    def handle_unix_signal(signum, frame):
        sys.exit()
    signal.signal(signal.SIGINT, handle_unix_signal)
    labels = unit.get_meter_labels()
    while 1:
        # At higher sampling rate, this causes timeout frequently.
        try:
            meters = unit.get_meters()
            for name in sorted(meters):
                print('{0}: {1:08x}'.format(name, meters[name]))
        except Exception as e:
            pass
        print('')
        time.sleep(0.1)
    return True

cmds = {
    'clock-source':         handle_clock_source,
    'input-volume':         handle_input_volume,
    'aux-input-volume':     handle_aux_input_volume,
    'aux-output-volume':    handle_aux_output_volume,
    'mixer-routing':        handle_mixer_routing,
    'output-volume':        handle_output_volume,
    'output-source':        handle_output_source,
    'headphone-volume':     handle_headphone_volume,
    'headphone-source':     handle_headphone_source,
    'listen-metering':      handle_listen_metering,
}

fullpath = CuiKit.seek_snd_unit_path()
if fullpath:
    unit = MaudioNormal(fullpath)
    CuiKit.dispatch_command(unit, cmds)
