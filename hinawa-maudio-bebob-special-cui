#!/usr/bin/env python3

import time
import signal
import sys

from misc.cui_kit import CuiKit
from bebob.maudio_special import MaudioSpecial

def handle_input_volume(unit, args):
    CHS = (0, 1)
    OPS = ('set', 'get')
    targets = unit.get_input_labels()
    if len(args) >= 1 and args[0] in targets:
        target = args[0]
        if len(args) >= 2 and int(args[1]) in CHS:
            ch = int(args[1])
            if len(args) >= 3 and args[2] in OPS:
                op = args[2]
                if len(args) >= 4 and op == 'set':
                    db = float(args[3])
                    unit.set_input_volume(target, ch, db)
                    return True
                else:
                    print(unit.get_input_volume(target, ch))
                    return True
    print('Arguments for input-volume command:')
    print('  input-volume TARGET CH [dB]')
    print('    TARGET: [{0}]'.format('|'.join(targets)))
    print('    CH:     [{0}]'.format('|'.join(map(str, CHS))))
    print('    OP:     [{0}]'.format('|'.join(OPS)))
    print('    dB:     [-128.0..128.0] if OP=set')
    return False

def handle_output_volume(unit, args):
    CHS = (0, 1)
    OPS = ('set', 'get')
    targets = unit.get_output_labels()
    if len(args) >= 1 and args[0] in targets:
        target = args[0]
        if len(args) >= 2 and int(args[1]) in CHS:
            ch = int(args[1])
            if len(args) >= 3 and args[2] in OPS:
                op = args[2]
                if len(args) >= 4 and op == 'set':
                    db = float(args[3])
                    unit.set_output_volume(target, ch, db)
                    return True
                elif op == 'get':
                    print(unit.get_output_volume(target, ch))
                    return True
    print('Arguments for output-volume command:')
    print('  output-volume TARGET CH OP [dB]')
    print('    TARGET: [{0}]'.format('|'.join(targets)))
    print('    CH:     [{0}]'.format('|'.join(map(str, CHS))))
    print('    OP:     [{0}]'.format('|'.join(OPS)))
    print('    dB:     [-128.0..128.0] if OP=set')
    return False

def handle_aux_volume(unit, args):
    CHS = (0, 1)
    OPS = ('set', 'get')
    if len(args) >= 1 and int(args[0]) in CHS:
        ch = int(args[0])
        if len(args) >= 2 and args[1] in OPS:
            op = args[1]
            if len(args) >= 3 and op == 'set':
                db = float(args[2])
                unit.set_aux_volume(ch, db)
                return True
            elif op == 'get':
                print(unit.get_aux_volume(ch))
                return True
    print('Arguments for aux-volume command:')
    print('  aux-volume CH OP [dB]')
    print('    CH:    [{0}]'.format('|'.join(map(str, CHS))))
    print('    OP:    [{0}]'.format('|'.join(OPS)))
    print('    dB:    [-128.0..128.0] if OP=set')
    return False

def handle_headphone_volume(unit, args):
    CHS = (0, 1)
    OPS = ('set', 'get')
    targets = unit.get_headphone_labels()
    if len(args) >= 1 and args[0] in targets:
        target = args[0]
        if len(args) >= 2 and int(args[1]) in CHS:
            ch = int(args[1])
            if len(args) >= 3 and args[2] in OPS:
                op = args[2]
                if len(args) >= 4 and op == 'set':
                    db = float(args[3])
                    unit.set_headphone_volume(target, ch, db)
                    return True
                elif op == 'get':
                    print(unit.get_headphone_volume(target, ch))
                    return True
    print('Arguments for headphone-volume command:')
    print('  headphone-volume TARGET CH [dB]')
    print('    TARGET: [{0}]'.format('|'.join(targets)))
    print('    CH:     [{0}]'.format('|'.join(map(str, CHS))))
    print('    OP:     [{0}]'.format('|'.join(OPS)))
    print('    dB:     [-128.0..128.0] if OP=set')
    return False

def handle_aux_input(unit, args):
    CHS = (0,1 )
    OPS = ('set', 'get')
    targets = unit.get_input_labels()
    if len(args) >= 1 and args[0] in targets:
        target = args[0]
        if len(args) >= 2 and int(args[1]) in CHS:
            ch = int(args[1])
            if len(args) >= 3 and args[2] in OPS:
                op = args[2]
                if len(args) >= 4 and op == 'set':
                    db = float(args[3])
                    unit.set_aux_input(target, ch, db)
                    return True
                else:
                    print(unit.get_aux_input(target, ch))
                    return True
    print('Arguments for aux-input command:')
    print('  aux-input TARGET CH [dB]')
    print('    TARGET:  [{0}]'.format('|'.join(targets)))
    print('    CH:      [{0}]'.format('|'.join(map(str, CHS))))
    print('    OP:      [{0}]'.format('|'.join(OPS)))
    print('    dB:      [-128.0..128.0] if OP=set')
    return False

def handle_mixer_routing(unit, args):
    OPS =  ('set', 'get')
    targets = unit.get_mixer_labels()
    sources = unit.get_mixer_source_labels()
    if len(args) >= 1 and args[0] in targets:
        target = args[0]
        if len(args) >= 2 and args[1] in sources:
            source = args[1]
            if len(args) >= 3 and args[2] in OPS:
                op = args[2]
                if len(args) >= 4 and op == 'set':
                    enable = bool(int(args[3]))
                    unit.set_mixer_routing(target, source, enable)
                    return True
                elif op == 'get':
                    print(unit.get_mixer_routing(target, source))
                    return True
    print('Arguments for mixer-routing command:')
    print('  mixer-routing MIXER SRC OP [ENABLE]')
    print('    MIXER:  [{0}]'.format('|'.join(targets)))
    print('    SRC:    [{0}]'.format('|'.join(sources)))
    print('    OP:     [{0}]'.format('|'.join(OPS)))
    print('    ENABLE: [0|1]')
    return False

def handle_headphone_source(unit, args):
    OPS = ('set', 'get')
    targets = unit.get_headphone_labels()
    if len(args) >= 1 and args[0] in targets:
        target = args[0]
        if len(args) >= 2 and args[1] in OPS:
            op = args[1]
            sources = unit.get_headphone_source_labels(target)
            if len(args) >= 3 and op == 'set' and args[2] in sources:
                source = args[2]
                unit.set_headphone_source(target, source)
                return True
            elif op == 'get':
                print(unit.get_headphone_source(target))
                return True
    print('Arguments for headphone-source command:')
    print('  headphone-source TARGET OP [SRC]')
    print('    TARGET:  [{0}]'.format('|'.join(targets)))
    print('    OP:      [{0}]'.format('|'.join(OPS)))
    for target in targets:
        sources = unit.get_headphone_source_labels(target)
        print('    SRC:     [{0}]'.format('|'.join(sources)))

def handle_output_source(unit, args):
    OPS = ('set', 'get')
    targets = unit.get_output_labels()
    if len(args) >= 1 and args[0] in targets:
        target = args[0]
        if len(args) >= 2 and args[1] in OPS:
            op = args[1]
            sources = unit.get_output_sources(target)
            if len(args) >= 3 and op == 'set' and args[2] in sources:
                source = args[2]
                unit.set_output_source(output, source)
                return True
            elif op == 'get':
                print(unit.get_output_source(output))
                return True
    print('Arguments for output-source command:')
    print('  output-source TARGET OP [SRC]')
    print('    TARGET:  [{0}]'.format('|'.join(targets)))
    print('    OP:      [{0}]'.format('|'.join(OPS)))
    for target in targets:
        sources = unit.get_output_source_labels(target)
        print('    SRC:     [{0}]'.format('|'.join(sources)))

def handle_listen_metering(unit, args):
    # This is handled by another context.
    def handle_unix_signal(signum, frame):
        sys.exit()
    signal.signal(signal.SIGINT, handle_unix_signal)
    while 1:
        # At higher sampling rate, this causes timeout frequently.
        try:
            meters = unit.get_meters()
            for name in sorted(meters):
                print('{0}: {1:04x}'.format(name, meters[name]))
        except Exception as e:
            pass
        print('')
        time.sleep(0.1)
    return True

cmds = {
    'input-volume':     handle_input_volume,
    'output-volume':    handle_output_volume,
    'aux-volume':       handle_aux_volume,
    'headphone-volume': handle_headphone_volume,
    'aux-input':        handle_aux_input,
    'mixer-routing':    handle_mixer_routing,
    'headphone-source': handle_headphone_source,
    'output-source':    handle_output_source,
    'listen-metering':  handle_listen_metering,
}

fullpath = CuiKit.seek_snd_unit_path()
if fullpath:
    unit = MaudioSpecial(fullpath)
    CuiKit.dispatch_command(unit, cmds)
