#!/usr/bin/env python3

import time
import signal
import sys

from misc.cui_kit import CuiKit
from bebob.maudio_special import MaudioSpecial

def handle_input_volume(unit, args):
    if len(args) > 1:
        target = args[0]
        ch = int(args[1])
        if target in unit.get_input_labels() and ch < 2:
            if len(args) > 2:
                db = float(args[2])
                unit.set_input_volume(target, ch, db)
            else:
                print(unit.get_input_volume(target, ch))
            return True
    print('Arguments for input-volume command:')
    print('  target:    [{0}]'.format((', ').join(unit.get_input_labels())))
    print('  ch:        [0, 1]')
    print('  dB:        [-128.0..128.0]')
    return False

def handle_output_volume(unit, args):
    if len(args) > 1:
        target = args[0]
        ch = int(args[1])
        if target in unit.get_output_labels() and ch < 2:
            if len(args) > 2:
                db = float(args[2])
                unit.set_output_volume(target, ch, db)
            else:
                print(unit.get_output_volume(target, ch))
            return True
    print('Arguments for output-volume command:')
    print('  target:    [{0}]'.format((', ').join(unit.get_output_labels())))
    print('  ch:        [0, 1]')
    print('  dB:        [-128.0..128.0]')
    return False

def handle_aux_volume(unit, args):
    if len(args) > 0:
        ch = int(args[0])
        if ch < 2:
            if len(args) > 1:
                db = float(args[1])
                unit.set_aux_volume(ch, db)
            else:
                print(unit.get_aux_volume(ch))
            return True
    print('Arguments for aux-volume command:')
    print('  ch:        [0, 1]')
    print('  dB:        [-128.0..128.0]')
    return False

def handle_headphone_volume(unit, args):
    if len(args) > 1:
        target = args[0]
        ch = int(args[1])
        if target in unit.get_headphone_labels() and ch < 2:
            if len(args) > 2:
                db = float(args[2])
                unit.set_headphone_volume(target, ch, db)
            else:
                print(unit.get_headphone_volume(target, ch))
            return True
    print('Arguments for headphone-volume command:')
    print('  target:    [{0}]'.format((', ').join(unit.get_headphone_labels())))
    print('  ch:        [0, 1]')
    print('  dB:        [-128.0..128.0]')
    return False

def handle_aux_input(unit, args):
    if len(args) > 1:
        target = args[0]
        ch = int(args[1])
        if target in unit.get_input_labels() and ch < 2:
            if len(args) > 2:
                db = float(args[2])
                unit.set_aux_input(target, ch, db)
            else:
                print(unit.get_aux_input(target, ch))
            return True
    print('Arguments for aux-input command:')
    print('  target:    [{0}]'.format((', ').join(unit.get_input_labels())))
    print('  ch:        [0, 1]')
    print('  dB:        [-128.0..128.0]')
    return False

def handle_mixer_routing(unit, args):
    if len(args) > 1:
        mixer = args[0]
        source = args[1]
        if (mixer in unit.get_mixer_labels() and
            source in unit.get_mixer_source_labels()):
            if len(args) > 2:
                value = int(args[2])
                unit.set_mixer_routing(mixer, source, value)
            else:
                print(unit.get_mixer_routing(mixer, source))
            return True
    print('Arguments for mixer-routing command:')
    print('  mixer-routing mixer source [state]')
    print('  mixer:     {0}'.format(unit.get_mixer_labels()))
    print('  source:    {0}'.format(unit.get_input_labels()))
    print('  state:     0, 1')
    return False

def handle_headphone_source(unit, args):
    if len(args) > 1:
        headphone = args[0]
        source = args[1]
        if headphone in unit.get_headphone_labels() and \
           source in unit.get_headphone_source_labels(headphone):
            if len(args) > 2:
                value = int(args[2])
                unit.set_headphone_source(headphone, source, value)
            else:
                print(unit.get_headphone_source(headphone, source))
            return True
    print('Arguments for headphone-source command:')
    print('  headphone-source headphone source')
    print('    headphone: {0}'.format(', '.join(unit.get_headphone_labels())))
    for target in unit.get_headphone_labels():
        print('    source:    {0}'.format(', '.join(unit.get_headphone_source_labels(target))))
    print('    value:     0, 1')

def handle_output_source(unit, args):
    if len(args) > 0:
        output = args[0]
        if output in unit.get_output_labels():
            if len(args) > 1:
                source = args[1]
                unit.set_output_source(output, source)
            else:
                print(unit.get_output_source(output))
            return True
    print('Arguments for output-source command:')
    print('  output-source output source')
    outputs = unit.get_output_labels()
    print('    output: {0}'.format(', '.join(outputs)))
    for output in outputs:
        print('    source ({0}): {1}'.format(output, unit.get_output_source_labels(output)))

def handle_listen_metering(unit, args):
    # This is handled by another context.
    def handle_unix_signal(signum, frame):
        sys.exit()
    signal.signal(signal.SIGINT, handle_unix_signal)
    while 1:
        # At higher sampling rate, this causes timeout frequently.
        try:
            meters = unit.get_meters()
            for name in sorted(meters):
                print('{0}: {1:04x}'.format(name, meters[name]))
        except Exception as e:
            pass
        print('')
        time.sleep(0.1)
    return True

cmds = {
    'input-volume':     handle_input_volume,
    'output-volume':    handle_output_volume,
    'aux-volume':       handle_aux_volume,
    'headphone-volume': handle_headphone_volume,
    'aux-input':        handle_aux_input,
    'mixer-routing':    handle_mixer_routing,
    'headphone-source': handle_headphone_source,
    'output-source':    handle_output_source,
    'listen-metering':  handle_listen_metering,
}

fullpath = CuiKit.seek_snd_unit_path()
if fullpath:
    unit = MaudioSpecial(fullpath)
    CuiKit.dispatch_command(unit, cmds)
